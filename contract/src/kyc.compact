pragma language_version >= 0.20;

import CompactStandardLibrary;

/**
 * The on-chain fingerprint of the identity.
 */
export ledger kyc_commitment: Bytes<32>;

/**
 * Step 1: Registration
 */
export circuit register(commitment: Bytes<32>): [] {
    kyc_commitment = disclose(commitment);
}

/**
 * Step 2: Full Identity Ownership Proof
 */
export circuit prove_identity(secret: Bytes<32>): [] {
    assert(kyc_commitment == persistentHash<Bytes<32>>(secret), "Identity verification failed: Secret does not match commitment");
}

/**
 * Step 3: Dynamic Age Eligibility Proof
 */
export circuit prove_age_eligible(current_year: Uint<16>, birth_year: Uint<32>, min_age: Uint<16>, secret: Bytes<32>): [] {
    assert(kyc_commitment == persistentHash<Bytes<32>>(secret), "Identity mismatch");
    const cy32 = current_year as Uint<32>;
    const min32 = min_age as Uint<32>;
    assert(cy32 - birth_year >= min32, "Age Requirement Not Met: Access Denied");
}

/**
 * Step 4: Residency Verification
 * country_code: 1 for US, 2 for UK, etc. (Simulated mapping)
 */
export circuit prove_residency(required_country: Uint<16>, user_country: Uint<16>, secret: Bytes<32>): [] {
    assert(kyc_commitment == persistentHash<Bytes<32>>(secret), "Identity mismatch");
    assert(user_country == required_country, "Residency Blocked: Country does not match requirements");
}

/**
 * Step 5: Generic Verification (The "Check" side)
 */
export circuit verify_claim(claimed_hash: Bytes<32>): [] {
    assert(kyc_commitment == claimed_hash, "Verification Failed: On-chain identity does not match provided proof");
}
